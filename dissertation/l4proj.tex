\pdfoutput=1

\documentclass{l4proj}

%
% put any packages here
%

\begin{document}
\title{Deontic Logic Prover}
\author{Leisha Hussien}
\date{2015/2016}
\maketitle

\begin{abstract}
A formalisation of deontic logic to represent the obligations, prohibitions and permissions within a system, which can then be checked for coherency and consistency to determine the validity of the set of rules.
\end{abstract}

\educationalconsent

\tableofcontents
%==============================================================================

% Suggested outline:

%  * Introduction (2-3 pages).

%   - Background and Motivation
%   - Objectives and achievements 
%   - Structure of remaining document

%  * Literature Review (6-7).

%   (convince the reader you know what you are talking about and are heading in the right direction). 

%  - Background on history of deontic logic and variants.

%  -  Application in CS and other domains, e.g. ethics.

%  - Tool support provided by others if any.

% * Design/implementation/evaluation chapters (10-15)

%  * Conclusions / future work. (2-3).

%  * References

%  * Appendix.

\chapter{Introduction}
\pagenumbering{arabic}

\section{Background and Motivation}
Deontic logic is a logic of duty, which formalises normative concepts of what should and should not be done. These conceptions can include obligations, prohibitions and permissions, as well as legal notions such as claims, powers, immunities and liberties, though what is considered under the remit of deontic logic depends largely on what form of deontic logic is in use. For my purposes, I will largely be concerned with obligations, prohibitions and permissions, as I feel they are the most relevant to the project I am pursuing. 
%Briefly explain what deontic logic is, why I'd want to do what I'm doing. 

\section{Objectives and Achievements}
%What did I set out to achieve and what have I achieved. 

\section{Structure}
I will now set out the history of deontic logic, as well as current and potential applications of deontic logic, and then I will examine existing tool support for the issue I have presented. I will then explain the design and implementation of my software, broken down into the lexical specification of the flavour of deontic logic I am working with and the proof strategy for a set of rules. I will then evaluate the success of what I have achieved against what I initially set out to achieve. Once this is complete, I will present my conclusions about what the work I have done shows, and also suggest potential avenues of future work. 

\chapter{Literature Review}

\section{Development of Deontic Logic}%talk about the development
Deontic logic, as I have already explained, is a logic of duty. Duties can be understood in a Kantian sense, wherein the justification of actions or becomings that are expected of agents is grounded in a respect for the laws which agents are bound to\cite{sep-kant-moral}. These laws can be anything from the moral law which can be said to govern all rational beings, to the legislation local to certain countries that applies only to their citizens, to the expected behaviour of an employee within a company under that company's code of ethics. 

Deontic logic contains the usual formal logic operators, such as negations, biconditionals, conjunctions and disjunctions. It can then incorporate many concepts, but here I will focus on obligations, prohibitions and permissions. Obligations are those things which agents are required to perform or become, prohibitions are those things which agents are forbidden from performing or becoming, and permissions are those things which agents are neither required to nor forbidden from performing or becoming. In other words, obligations are things we should do, prohibitions are things we should not do and permissions are things we are allowed to do. 

\subsection{Types of Deontic Logic}

\subsubsection{Standard Deontic Logic}
Standard deontic logic is a monadic logic which extends propositional logic. If O represents obligation, the concepts can be formalised as follows: if A is some obligation, O(A); if A is some prohibition, O(¬A); if A is some permission, ¬O(A) |\& ¬O(¬A). 

Standard deontic logic faces the contrary-to-duties problem. It is not implausible that it could be forbidden that C, but in the case of C, it could still be expected that A. The classic example is the gentle murderer; murder is forbidden, but if an agent is going to commit murder, they are obliged to do it gently. Standard deontic logic could represent these cases as follows: O¬(C) |\& C -> O(A), but this is paradoxical, and not a satisfactory representation of what is happening with contrary-to-duties obligations. 

\subsubsection{Dyadic Deontic Logic}
Dyadic deontic logic introduces a context as a way to respond to the contrary-to-duties problem. If A is an obligation that only applies given a context C, O(A | C) and so following. This allows for seemingly contradictory statements such as O¬(C) |\& O(A | C) to coexist without conflict. 

\subsubsection{Non-Monotonic Deontic Logic}
Non-monotonic deontic logic introduces consistency\cite{Powers}. This is useful both for dealing with conflicting obligations and for handling conditional obligations\cite{Horty}. Following Reiter's symbolisation\cite{Reiter}, if A is an obligation, and C is some condition that A must be consistent with in order to hold, \( \frac{C : O(A)}{O(A)} \). 

\subsubsection{Predicate Deontic Logic}
Predicate deontic logic\cite{predicate} introduces quantifiers, which allow for specification of what statements actually refer to. If x is some agent and A is some obligation incumbent upon all of x, \( \forall{x(O(A))} \). 

\section{Applications of Deontic Logic}%Places it is already being used/could be used. Look for CS examples as well as others. 
Deontic logic lends itself well to applications within law, due to the aforementioned grounding in a respect for laws. One way to implement this is to characterise the law as a system of norms\cite{law-jonessergot}, which can then be represented with deontic expressions. 

Applications within Computer Science can be categorised as follows\cite{meyer93applications}: fault-tolerant computer systems, normative user behaviour, policy specification, normative organisation behaviour and normative integrity constraints. 

\subsection{Existing Functionality}%Things which already exist which kind of do what I'm doing - explain why they aren't sufficient and what I'm doing differently. 
One tool which has been explicitly developed to operationalise deontic logic is KED\cite{KED}, a deontic theorem prover implemented in Haskell. It works with standard deontic logic, and its proof strategy follows these steps: define the labels which represent the worlds and paths, unify the labels for the relevant worlds, use the properties of transitivity and symmetry to reduce the set of labels, generally unify the set of labels, and finally make use of rules of inference, such as modus ponens, to prove by contradiction that the theorem is correct. 

Another tool, ESPLEX, formalises legislation in a deontic way in the field of agricultural tenancies\cite{ESPLEX}, and is implemented in Prolog. It first produces a normalised version of a legal text, splitting the sentences into a series of conditions (IF statements) and consequences (THEN statements). From this, it produces a reduced normalised version, which produces prescriptions (obligations, prohibitions and permissions), procedural rules for these prescriptions and conditions for the prescriptions being held. These are then translated into rules to be stored in the Prolog knowledge base. The knowledge base can be searched either by searching the rules or by searching the network. 

A similar tool, TAXMAN, models concepts within the legal area that applies to corporate reorganisation\cite{TAXMAN}. It stores the facts of such a reorganisation and uses formalised definitions of the legislation to determine whether or not it can be considered a tax-free transaction. 

\chapter{Design}

\section{Lexical Specification}

\section{Proof Strategy}

\chapter{Implementation}

\section{Lexical Specification}

\section{Proof Strategy}

\chapter{Evaluation}

\section{Lexical Specification}

\section{Proof Strategy}

\chapter{Conclusions and Future Work}

\section{Conclusions}

\section{Future Work}

%%%%%%%%%%%%%%%%
%              %
%  APPENDICES  %
%              %
%%%%%%%%%%%%%%%%
\begin{appendices}

\chapter{Running the Programs}
An example of running from the command line is as follows:
\begin{verbatim}
\end{verbatim}

\chapter{Test Data}
%include tests used

\end{appendices}

%%%%%%%%%%%%%%%%%%%%
%   BIBLIOGRAPHY   %
%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{plain}
\bibliography{bib}

\end{document}

