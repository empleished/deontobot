\pdfoutput=1

\documentclass{l4proj}

\usepackage[english]{babel}
\usepackage{csquotes}

\begin{document}
\title{Deontic Logic Prover}
\author{Leisha Hussien}
\date{2015/2016}
\maketitle

\begin{abstract}

\end{abstract}

\educationalconsent

\tableofcontents
%==============================================================================

% Suggested outline:

%  * Introduction (2-3 pages).

%   - Background and Motivation
%   - Objectives and achievements 
%   - Structure of remaining document

%  * Literature Review (6-7).

%   (convince the reader you know what you are talking about and are heading in the right direction). 

%  - Background on history of deontic logic and variants.

%  -  Application in CS and other domains, e.g. ethics.

%  - Tool support provided by others if any.

% * Design/implementation/evaluation chapters (10-15)

%  * Conclusions / future work. (2-3).

%  * References

%  * Appendix.

\chapter{Introduction}
\pagenumbering{arabic}

\section{Background and Motivation}%Briefly explain what deontic logic is, why I'd want to do what I'm doing. 
Deontic logic is a logic of duty, which formalises normative concepts of what should and should not be done. These conceptions can include obligations, prohibitions and permissions, as well as the Hohfeldian incidents\cite{Hohfeld} of claims, powers, immunities and liberties, though what is considered under the remit of deontic logic depends largely on what form of deontic logic is in use. For my purposes, I will largely be concerned with obligations, prohibitions and permissions, as I feel they are the most relevant to the project I am pursuing.

Concepts of obligation, prohibition and permission pervade everyday life, from legal proceedings to codes of ethics to database integrity. 

%duties are everywhere
%vitally important that we get these things right
%so automating such a process is of use

\section{Objectives and Achievements} %What did I set out to achieve and what have I achieved. 

\section{Structure}
I will now set out the history of deontic logic, as well as current and potential applications of deontic logic, and then I will examine existing tool support for the issue I have presented. I will then explain the design and implementation of my software, broken down into the lexical specification of the flavour of deontic logic I am working with and the proof strategy for a given set of rules and facts. I will then evaluate the success of what I have achieved against what I initially set out to achieve. Once this is complete, I will present my conclusions about what the work I have done shows, and also suggest potential avenues of future work. 

\chapter{Literature Review}

\section{Development of Deontic Logic}%talk about the development
Deontic logic, as I have already explained, is a logic of duty. Duties can be understood in a Kantian sense, wherein the justification of maxims that are expected of agents is grounded in a respect for the laws which agents are bound to\cite{sep-kant-moral}. These laws can be anything from the moral law which can be said to govern all rational beings, to the legislation local to certain countries that applies only to their citizens, to the expected behaviour of an employee within a company under that company's code of ethics. 

Deontic logic contains the usual formal logic operators, such as negations, biconditionals, conjunctions and disjunctions. It can then incorporate many concepts, but here I will focus on obligations, prohibitions and permissions. Obligations are those things which agents are required to do, prohibitions are those things which agents are forbidden from doing, and permissions are those things which agents are neither required to do nor forbidden from doing. In other words, obligations are things we should do, prohibitions are things we should not do and permissions are things we are allowed to do. 

Deontic logic says nothing about the content of these maxims, broadly speaking; where this comes from is determined by deontological theories, which can then be assessed for adequacy on their own terms. Indeed, in certain contexts, many deontological theories do not seem applicable. It makes no sense to talk of things like the rational will dictating the maxims to be accepted when these maxims concern database integrity, for example. However, there is a clearer story to be told when dealing with codes of ethics. Following Kant\cite{groundwork}: 

\blockquote{It can lie nowhere else than in the principle of the will, regardless of the ends that can be effected by such action; for the will stands halfway between its a priori principle, which is formal, and its a posteriori incentive, which is material, as it were at a crossroads, and since it must after all be determined by something, it will have to be determined by the formal principle of willing as such when an action is done from duty, as every material principle has been taken away from it. The third proposition, as the conclusion from both previous ones, I would express as follows: duty is the necessity of an action from respect for the law. For the object as the effect of the action I have in mind I can indeed have inclination, but never respect, precisely because it is merely an effect and not activity of a will. Likewise, I cannot have respect for inclination as such, whether it is mine or that of another; I can at most in the first case approve of it, in the second at times love it myself, i.e. view it as favourable to my own advantage. Only what is connected with my will merely as ground, never as effect, what does not serve my inclination, but outweighs it, or at least excludes it entirely from calculations when we make a choice, hence the mere law by itself, can be an object of respect and thus a command.}

This is often described as the autonomy formula of the categorical imperative. Simply put, it is that the rational will should determine universal law. From this, we can derive an approach to validating sets of deontic maxims, and thereby providing sets of laws. One convincing approach is ensuring that every maxim must be consistent with the rest of the set, and that the set must then form a coherent system of maxims\cite{Powers}. If there are inconsistent rules in the set, it is unreasonable to expect these maxims to be followed; it is impossible for $P$ and \( \neg \) $P$ to be true, so impossible for them to be justified coherently in a set. Powers derives two rules for this system: R-in and R-out. 

R-in states that a maxim, $m_i$ is allowed to be part of the set of acceptable maxims, $M$, if $m_i$ is consistent with the ethical 
system, $G$. That is, $m_i \in M \iff G \vdash m_i $. 

R-out states that if a maxim, $m_i$, becomes inconsistent with the ethical system, $G$, $m_i$ is no longer allowed in the set of acceptable maxims, $M$. That is, $m_i \notin M \rightarrow \neg(G \vdash m_i)$. 

%-GENERALISM VS PARTICULARISM
%--generalism + fregean concepts + algorithms

\section{Types of Deontic Logic}

\subsection{Standard Deontic Logic}
Standard deontic logic is a monadic logic which extends propositional logic. If $O$ represents obligation, the concepts can be formalised as follows: if $A$ is some obligation, then $O(A)$; if $A$ is some prohibition, then $O$(\( \neg \)$A)$; if $A$ is some permission, then \( \neg \)$O(A)$ \& \( \neg \)$O$(\( \neg \)$A)$. For example, if there is a general prohibition on murder, and the action of murder is represented by $A$, this can be represented as $O$(\( \neg \)$A)$. Nothing more needs to be done to show that $O(A)$ holds once $A$ is proven to be true. 

Standard deontic logic faces the contrary-to-duties problem. It is not implausible that it could be forbidden that $C$, but in the case of $C$, it could still be expected that $A$. The classic example is the gentle murderer; murder is forbidden, but if an agent is going to commit murder, they are obliged to do it in a way that causes the least amount of suffering. Standard deontic logic could represent these cases as follows: if there is a general prohibition on murder and the action of murder is represented by C, but if an agent is committing murder they are obliged to murder gently and this can be represented by $O(A)$, then this can be represented as $O$(\( \neg \)$C)$ \& $C$ \( \to \) $O(A)$. However, this is paradoxical, as $C$ and \( \neg \)$C$ cannot be true at the same time. There are ways to answer this objection within standard deontic logic, but it still does not give a satisfactory representation of what is happening with contrary-to-duties obligations. It seems like the case of a duty being violated is something stronger than a condition, and is an action in the same way that the ensuing obligation is. 

\subsection{Non-Monotonic Deontic Logic}
Non-monotonic deontic logic introduces consistency\cite{Powers}. This is useful both for dealing with conflicting obligations and for handling conditional obligations\cite{Horty}. Following Reiter's symbolisation of default logic\cite{Reiter}, if $A$ is an obligation, and $C$ is some condition that $A$ must be consistent with in order to hold, \( \frac{C : O(A)}{O(A)} \). This also neatly handles the contrary-to-duties problem; if there is a general prohibition on murder, and the action of murder is represented by C, but if in the context where an agent is committing murder they are obliged to kill gently and this can be represented by O(A), then \( \frac{C : O(A)}{O(A)} \). The justification is the same as the conclusion, and is true only in the case of there being no facts, or defeater conditions, which would make it false. This is what is known as defeasibility. 

Dyadic deontic logic is a non-monotonic logic which introduces a context as a way to respond to the contrary-to-duties problem. Rather than there being simply an ideal world, where duties are fulfilled, and a non-ideal world, where they are not, there can be more or less ideal worlds depending on the number of obligations that are fulfilled. In dyadic deontic logic, if $A$ is an obligation that only applies given a context $C$, $O(A$ \textbar $C)$ and so following. This allows for seemingly contradictory statements such as $O($\( \neg \)$C)$ \& $O(A$ \textbar $C)$ to coexist without conflict. For example, if there is a general prohibition on murder, and the action of murder is represented by $C$, but if in the context where an agent is committing murder they are obliged to kill gently and this can be represented by $O(A)$, then $O($\( \neg \)$C)$ \& $O(A$ \textbar $C)$. 

However, despite effectively capturing an important aspect of reasoning, non-monotonic logic fails a first-order logic requirement for semi-decidability of set membership. It cannot guarantee whether a maxim is forbidden or obliged, even when it is in fact one of the two, which is problematic for a formalised system. 

\subsection{Predicate Deontic Logic}
Predicate logic\cite{predicate} introduces quantifiers, which allow for specification of what statements actually refer to. Statements can range over all members of a group, (at least) one member of a group, no members of a group or not all members of a group. If $x$ is some agent and $A$ is some obligation incumbent upon all of $x$, \( \forall{x(O(A))} \). For example, the general prohibition on murder, ($A$), which applies to all rational beings, ($x$), can be represented as \( \forall{x(O( \neg A))} \). To show the distinction, if all citizens ($x$) are obliged not to murder, but officers of the law ($y$) are permitted to murder in certain cases, this can be represented as \( \forall{x(O( \neg A))} \) \& \( \forall{y( \neg O( \neg A) \& \neg O(A)} \). These are not contradictory maxims in predicate logic, so it allows for much more complex sets of deontic rules. 

However, this still faces problems. %predicate logic is a really weird way of doing deontic duties 

\section{Applications of Deontic Logic}
Deontic logic lends itself well to applications within law, due to the aforementioned grounding in a respect for laws. One way to implement this is to characterise the law as a system of norms\cite{law-jonessergot}, which can then be represented with deontic expressions. 

ESPLEX formalises legislation in a deontic way in the field of agricultural tenancies\cite{ESPLEX}, and is implemented in Prolog. It first produces a normalised version of a legal text, splitting the sentences into a series of conditions (IF statements) and consequences (THEN statements). From this, it produces a reduced normalised version, which produces prescriptions (obligations, prohibitions and permissions), procedural rules for these prescriptions and conditions for the prescriptions being held. These are then translated into rules to be stored in the Prolog knowledge base. The knowledge base can be searched either by searching the rules or by searching the network.

TAXMAN models concepts within the legal area that applies to corporate reorganisation\cite{TAXMAN}. It stores the facts of such a reorganisation and uses formalised definitions of the legislation to determine whether or not it can be considered a tax-free transaction. 

Applications within Computer Science can be categorised as follows\cite{meyer93applications}: fault-tolerant computer systems, normative user behaviour, policy specification, normative organisation behaviour and normative integrity constraints. %EXPAND THIS

One application within policy specification is system availability\cite{brunel04deontic}. After extending the logic with temporal operators, so it can be said that some obligation, A, needs to be done before a certain time, k, this obligation can be formally represented. From this, simple availability policies can be defined, and then checked for consistency. Violation of these policies is also easy to verify, as it can be checked whether the system is in accordance with all of the defined rules. 

Within integrity constraints, one application is the specification of information systems\cite{infosystems}, particularly with respect to soft constraints. Dyadic deontic logic, with its ideal and non-ideal worlds, can neatly describe what is going on when there is some constraint of a system that ideally should not be violated, and what should be done if it is. 

\section{Existing Functionality}
One tool which has been explicitly developed to operationalise deontic logic is KED\cite{KED}, a deontic theorem prover implemented in Haskell. It works with standard deontic logic, and its proof strategy follows these steps: define the labels which represent the worlds and paths, unify the labels for the relevant worlds, use the properties of transitivity and symmetry to reduce the set of labels, generally unify the set of labels, and finally make use of rules of inference, such as modus ponens, to prove by contradiction that the theorem is correct. 

%NHS Health Research Authority Decision Tool

\chapter{Design}
%more high level than implementation
%how could we do this
%what considerations do we have

\section{Lexical Specification}

As the finished product is not designed for any kind of specialist, it is important to take into consideration the needs of an average user. Most people will not be familiar with formal logic, particularly the frequently esoteric symbolism. 

%first order logic + notions of obligation
%conditions
%axioms
%atoms

\section{Proof Strategy}

%use generated tree to walk
%brute force prover
%simplify fact set using logic rules

\chapter{Implementation}
%what have i done
%how did i take on design considerations

\section{Lexical Specification}

I created an ANTLR grammar to outline the specification of rules for a system. These rules extended first order logic with notions of obligation, prohibition and permission. The grammar consists of parser rules and lexer rules. 

The lexer rules include 'OB', 'PRO' and 'PER' to represent obligation, prohibition and permission, as well as lexer rules for common first order logic operators. I chose to represent these as words rather than symbols, particularly 'then' rather than '->' because it makes the code more readable for the person specifying the rules of the system. Assigning of atoms to symbols is done with ':', as this os more intuitive in context than a possibly more traditional '='. 

The parser rules start with the program, which is made up of declarations, which are split into declarations of facts, in the form of 'C: some statement', and declarations of rules, which are one of three kinds of expression. Expressions are split into prefix expressions, which have an operator before some kind of statement; infix expressions, which have an operator between two statements; and if...then expressions, which have a statement enclosed by the IF operator and the THEN operator. 

ANTLR is used to generate a lexer and parser for the grammar. Once rules have been specified in a program with this grammar, a tree is generated of the various nodes of the program, which will then be used for the next stage of the process, the prover. 

\section{Proof Strategy}

The prover uses a brute force proof strategy to prove, given a set of facts, that these facts cohere with the defined set of rules, or not, as the case may be. 

%use generated tree to walk
%brute force prover
%simplify fact set using logic rules

\chapter{Evaluation}

\section{Lexical Specification}

\section{Proof Strategy}

\chapter{Conclusions and Future Work}

\section{Conclusions}

\section{Future Work}
%Hohfeldian incidents - formalise rights
%parser - Stanford Tagger

%%%%%%%%%%%%%%%%
%              %
%  APPENDICES  %
%              %
%%%%%%%%%%%%%%%%
\begin{appendices}

\chapter{Running the Programs}
An example of running from the command line is as follows:
\begin{verbatim}
\end{verbatim}

\chapter{Test Data}
%include tests used

\end{appendices}

%%%%%%%%%%%%%%%%%%%%
%   BIBLIOGRAPHY   %
%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{plain}
\bibliography{bib}

\end{document}

