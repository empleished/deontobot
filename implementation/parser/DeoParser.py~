# $ANTLR 3.1.2 Deo.g 2015-11-17 17:30:48

import sys
from antlr3 import *
from antlr3.compat import set, frozenset

from antlr3.tree import *



# for convenience in actions
HIDDEN = BaseRecognizer.HIDDEN

# token types
IFF=5
ASSN=12
STATE=17
RULE=9
RB=23
PER=15
LETTER=26
NOT=21
AND=19
ID=11
SPACE=28
EOF=-1
PRO=14
ACTION=16
OB=13
IF=4
EOL=29
EXPR=7
THEN=6
ALL=24
OR=20
AGENT=18
LB=22
DIGIT=27
EXISTS=25
COMMENT=30
FACT=8
EXIST=10

# token names
tokenNames = [
    "<invalid>", "<EOR>", "<DOWN>", "<UP>", 
    "IF", "IFF", "THEN", "EXPR", "FACT", "RULE", "EXIST", "ID", "ASSN", 
    "OB", "PRO", "PER", "ACTION", "STATE", "AGENT", "AND", "OR", "NOT", 
    "LB", "RB", "ALL", "EXISTS", "LETTER", "DIGIT", "SPACE", "EOL", "COMMENT"
]




class DeoParser(Parser):
    grammarFileName = "Deo.g"
    antlr_version = version_str_to_tuple("3.1.2")
    antlr_version_str = "3.1.2"
    tokenNames = tokenNames

    def __init__(self, input, state=None):
        if state is None:
            state = RecognizerSharedState()

        Parser.__init__(self, input, state)


        self.dfa19 = self.DFA19(
            self, 19,
            eot = self.DFA19_eot,
            eof = self.DFA19_eof,
            min = self.DFA19_min,
            max = self.DFA19_max,
            accept = self.DFA19_accept,
            special = self.DFA19_special,
            transition = self.DFA19_transition
            )






                
        self._adaptor = CommonTreeAdaptor()


        
    def getTreeAdaptor(self):
        return self._adaptor

    def setTreeAdaptor(self, adaptor):
        self._adaptor = adaptor

    adaptor = property(getTreeAdaptor, setTreeAdaptor)


    class prog_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)

            self.tree = None




    # $ANTLR start "prog"
    # Deo.g:21:1: prog : ( var_decl )+ ( rule_decl )+ EOF -> ^( PROG ( var_decl )* ( rule_decl )+ ) ;
    def prog(self, ):

        retval = self.prog_return()
        retval.start = self.input.LT(1)

        root_0 = None

        EOF3 = None
        var_decl1 = None

        rule_decl2 = None


        EOF3_tree = None
        stream_EOF = RewriteRuleTokenStream(self._adaptor, "token EOF")
        stream_var_decl = RewriteRuleSubtreeStream(self._adaptor, "rule var_decl")
        stream_rule_decl = RewriteRuleSubtreeStream(self._adaptor, "rule rule_decl")
        try:
            try:
                # Deo.g:21:6: ( ( var_decl )+ ( rule_decl )+ EOF -> ^( PROG ( var_decl )* ( rule_decl )+ ) )
                # Deo.g:21:8: ( var_decl )+ ( rule_decl )+ EOF
                pass 
                # Deo.g:21:8: ( var_decl )+
                cnt1 = 0
                while True: #loop1
                    alt1 = 2
                    LA1_0 = self.input.LA(1)

                    if (LA1_0 == ID) :
                        alt1 = 1


                    if alt1 == 1:
                        # Deo.g:21:8: var_decl
                        pass 
                        self._state.following.append(self.FOLLOW_var_decl_in_prog82)
                        var_decl1 = self.var_decl()

                        self._state.following.pop()
                        stream_var_decl.add(var_decl1.tree)


                    else:
                        if cnt1 >= 1:
                            break #loop1

                        eee = EarlyExitException(1, self.input)
                        raise eee

                    cnt1 += 1


                # Deo.g:21:18: ( rule_decl )+
                cnt2 = 0
                while True: #loop2
                    alt2 = 2
                    LA2_0 = self.input.LA(1)

                    if ((LB <= LA2_0 <= RB)) :
                        alt2 = 1


                    if alt2 == 1:
                        # Deo.g:21:18: rule_decl
                        pass 
                        self._state.following.append(self.FOLLOW_rule_decl_in_prog85)
                        rule_decl2 = self.rule_decl()

                        self._state.following.pop()
                        stream_rule_decl.add(rule_decl2.tree)


                    else:
                        if cnt2 >= 1:
                            break #loop2

                        eee = EarlyExitException(2, self.input)
                        raise eee

                    cnt2 += 1


                EOF3=self.match(self.input, EOF, self.FOLLOW_EOF_in_prog88) 
                stream_EOF.add(EOF3)

                # AST Rewrite
                # elements: rule_decl, var_decl
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 

                retval.tree = root_0

                if retval is not None:
                    stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                else:
                    stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                root_0 = self._adaptor.nil()
                # 21:38: -> ^( PROG ( var_decl )* ( rule_decl )+ )
                # Deo.g:21:41: ^( PROG ( var_decl )* ( rule_decl )+ )
                root_1 = self._adaptor.nil()
                # Deo.g:21:48: ( var_decl )*
                while stream_var_decl.hasNext():
                    self._adaptor.addChild(root_1, stream_var_decl.nextTree())


                stream_var_decl.reset();
                # Deo.g:21:58: ( rule_decl )+
                if not (stream_rule_decl.hasNext()):
                    raise RewriteEarlyExitException()

                while stream_rule_decl.hasNext():
                    self._adaptor.addChild(root_1, stream_rule_decl.nextTree())


                stream_rule_decl.reset()

                self._adaptor.addChild(root_0, root_1)



                retval.tree = root_0



                retval.stop = self.input.LT(-1)


                retval.tree = self._adaptor.rulePostProcessing(root_0)
                self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:

            pass

        return retval

    # $ANTLR end "prog"

    class rule_decl_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)

            self.tree = None




    # $ANTLR start "rule_decl"
    # Deo.g:24:1: rule_decl : ( expr )+ -> ^( RULE ( expr )+ ) ;
    def rule_decl(self, ):

        retval = self.rule_decl_return()
        retval.start = self.input.LT(1)

        root_0 = None

        expr4 = None


        stream_expr = RewriteRuleSubtreeStream(self._adaptor, "rule expr")
        try:
            try:
                # Deo.g:25:2: ( ( expr )+ -> ^( RULE ( expr )+ ) )
                # Deo.g:25:4: ( expr )+
                pass 
                # Deo.g:25:4: ( expr )+
                cnt3 = 0
                while True: #loop3
                    alt3 = 2
                    LA3_0 = self.input.LA(1)

                    if (LA3_0 == LB) :
                        alt3 = 1
                    elif (LA3_0 == RB) :
                        alt3 = 1


                    if alt3 == 1:
                        # Deo.g:25:4: expr
                        pass 
                        self._state.following.append(self.FOLLOW_expr_in_rule_decl117)
                        expr4 = self.expr()

                        self._state.following.pop()
                        stream_expr.add(expr4.tree)


                    else:
                        if cnt3 >= 1:
                            break #loop3

                        eee = EarlyExitException(3, self.input)
                        raise eee

                    cnt3 += 1



                # AST Rewrite
                # elements: expr
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 

                retval.tree = root_0

                if retval is not None:
                    stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                else:
                    stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                root_0 = self._adaptor.nil()
                # 25:15: -> ^( RULE ( expr )+ )
                # Deo.g:25:18: ^( RULE ( expr )+ )
                root_1 = self._adaptor.nil()
                root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(RULE, "RULE"), root_1)

                # Deo.g:25:25: ( expr )+
                if not (stream_expr.hasNext()):
                    raise RewriteEarlyExitException()

                while stream_expr.hasNext():
                    self._adaptor.addChild(root_1, stream_expr.nextTree())


                stream_expr.reset()

                self._adaptor.addChild(root_0, root_1)



                retval.tree = root_0



                retval.stop = self.input.LT(-1)


                retval.tree = self._adaptor.rulePostProcessing(root_0)
                self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:

            pass

        return retval

    # $ANTLR end "rule_decl"

    class var_decl_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)

            self.tree = None




    # $ANTLR start "var_decl"
    # Deo.g:28:1: var_decl : ID ASSN fact -> ^( VAR ID fact ) ;
    def var_decl(self, ):

        retval = self.var_decl_return()
        retval.start = self.input.LT(1)

        root_0 = None

        ID5 = None
        ASSN6 = None
        fact7 = None


        ID5_tree = None
        ASSN6_tree = None
        stream_ASSN = RewriteRuleTokenStream(self._adaptor, "token ASSN")
        stream_ID = RewriteRuleTokenStream(self._adaptor, "token ID")
        stream_fact = RewriteRuleSubtreeStream(self._adaptor, "rule fact")
        try:
            try:
                # Deo.g:29:2: ( ID ASSN fact -> ^( VAR ID fact ) )
                # Deo.g:29:4: ID ASSN fact
                pass 
                ID5=self.match(self.input, ID, self.FOLLOW_ID_in_var_decl144) 
                stream_ID.add(ID5)
                ASSN6=self.match(self.input, ASSN, self.FOLLOW_ASSN_in_var_decl146) 
                stream_ASSN.add(ASSN6)
                self._state.following.append(self.FOLLOW_fact_in_var_decl148)
                fact7 = self.fact()

                self._state.following.pop()
                stream_fact.add(fact7.tree)

                # AST Rewrite
                # elements: fact, ID
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 

                retval.tree = root_0

                if retval is not None:
                    stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                else:
                    stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                root_0 = self._adaptor.nil()
                # 29:21: -> ^( VAR ID fact )
                # Deo.g:29:24: ^( VAR ID fact )
                root_1 = self._adaptor.nil()
                self._adaptor.addChild(root_1, stream_ID.nextNode())
                self._adaptor.addChild(root_1, stream_fact.nextTree())

                self._adaptor.addChild(root_0, root_1)



                retval.tree = root_0



                retval.stop = self.input.LT(-1)


                retval.tree = self._adaptor.rulePostProcessing(root_0)
                self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:

            pass

        return retval

    # $ANTLR end "var_decl"

    class norm_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)

            self.tree = None




    # $ANTLR start "norm"
    # Deo.g:32:1: norm : ( OB | PRO | PER );
    def norm(self, ):

        retval = self.norm_return()
        retval.start = self.input.LT(1)

        root_0 = None

        set8 = None

        set8_tree = None

        try:
            try:
                # Deo.g:33:2: ( OB | PRO | PER )
                # Deo.g:
                pass 
                root_0 = self._adaptor.nil()

                set8 = self.input.LT(1)
                if (OB <= self.input.LA(1) <= PER):
                    self.input.consume()
                    self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set8))
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)


                retval.tree = self._adaptor.rulePostProcessing(root_0)
                self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:

            pass

        return retval

    # $ANTLR end "norm"

    class fact_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)

            self.tree = None




    # $ANTLR start "fact"
    # Deo.g:38:1: fact : ( ACTION | STATE | AGENT );
    def fact(self, ):

        retval = self.fact_return()
        retval.start = self.input.LT(1)

        root_0 = None

        set9 = None

        set9_tree = None

        try:
            try:
                # Deo.g:38:6: ( ACTION | STATE | AGENT )
                # Deo.g:
                pass 
                root_0 = self._adaptor.nil()

                set9 = self.input.LT(1)
                if (ACTION <= self.input.LA(1) <= AGENT):
                    self.input.consume()
                    self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set9))
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)


                retval.tree = self._adaptor.rulePostProcessing(root_0)
                self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:

            pass

        return retval

    # $ANTLR end "fact"

    class op_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)

            self.tree = None




    # $ANTLR start "op"
    # Deo.g:43:1: op : ( AND | OR | NOT | THEN | IF | IFF );
    def op(self, ):

        retval = self.op_return()
        retval.start = self.input.LT(1)

        root_0 = None

        set10 = None

        set10_tree = None

        try:
            try:
                # Deo.g:43:4: ( AND | OR | NOT | THEN | IF | IFF )
                # Deo.g:
                pass 
                root_0 = self._adaptor.nil()

                set10 = self.input.LT(1)
                if (IF <= self.input.LA(1) <= THEN) or (AND <= self.input.LA(1) <= NOT):
                    self.input.consume()
                    self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set10))
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)


                retval.tree = self._adaptor.rulePostProcessing(root_0)
                self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:

            pass

        return retval

    # $ANTLR end "op"

    class axiom_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)

            self.tree = None




    # $ANTLR start "axiom"
    # Deo.g:51:1: axiom : norm LB ACTION RB -> ^( AXIOM norm AGENT ACTION ) ;
    def axiom(self, ):

        retval = self.axiom_return()
        retval.start = self.input.LT(1)

        root_0 = None

        LB12 = None
        ACTION13 = None
        RB14 = None
        norm11 = None


        LB12_tree = None
        ACTION13_tree = None
        RB14_tree = None
        stream_LB = RewriteRuleTokenStream(self._adaptor, "token LB")
        stream_RB = RewriteRuleTokenStream(self._adaptor, "token RB")
        stream_ACTION = RewriteRuleTokenStream(self._adaptor, "token ACTION")
        stream_norm = RewriteRuleSubtreeStream(self._adaptor, "rule norm")
        try:
            try:
                # Deo.g:52:2: ( norm LB ACTION RB -> ^( AXIOM norm AGENT ACTION ) )
                # Deo.g:52:4: norm LB ACTION RB
                pass 
                self._state.following.append(self.FOLLOW_norm_in_axiom357)
                norm11 = self.norm()

                self._state.following.pop()
                stream_norm.add(norm11.tree)
                LB12=self.match(self.input, LB, self.FOLLOW_LB_in_axiom359) 
                stream_LB.add(LB12)
                ACTION13=self.match(self.input, ACTION, self.FOLLOW_ACTION_in_axiom361) 
                stream_ACTION.add(ACTION13)
                RB14=self.match(self.input, RB, self.FOLLOW_RB_in_axiom363) 
                stream_RB.add(RB14)

                # AST Rewrite
                # elements: ACTION, norm
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 

                retval.tree = root_0

                if retval is not None:
                    stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                else:
                    stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                root_0 = self._adaptor.nil()
                # 52:25: -> ^( AXIOM norm AGENT ACTION )
                # Deo.g:52:28: ^( AXIOM norm AGENT ACTION )
                root_1 = self._adaptor.nil()
                self._adaptor.addChild(root_1, stream_norm.nextTree())
                self._adaptor.addChild(root_1, self._adaptor.createFromType(AGENT, "AGENT"))
                self._adaptor.addChild(root_1, stream_ACTION.nextNode())

                self._adaptor.addChild(root_0, root_1)



                retval.tree = root_0



                retval.stop = self.input.LT(-1)


                retval.tree = self._adaptor.rulePostProcessing(root_0)
                self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:

            pass

        return retval

    # $ANTLR end "axiom"

    class existent_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)

            self.tree = None




    # $ANTLR start "existent"
    # Deo.g:55:1: existent : ( ALL | EXISTS );
    def existent(self, ):

        retval = self.existent_return()
        retval.start = self.input.LT(1)

        root_0 = None

        set15 = None

        set15_tree = None

        try:
            try:
                # Deo.g:56:2: ( ALL | EXISTS )
                # Deo.g:
                pass 
                root_0 = self._adaptor.nil()

                set15 = self.input.LT(1)
                if (ALL <= self.input.LA(1) <= EXISTS):
                    self.input.consume()
                    self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set15))
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)


                retval.tree = self._adaptor.rulePostProcessing(root_0)
                self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:

            pass

        return retval

    # $ANTLR end "existent"

    class expr_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)

            self.tree = None




    # $ANTLR start "expr"
    # Deo.g:60:1: expr : ( ( LB AGENT )* RB ( LB IF ( LB fact ( op fact )* )* RB THEN ( LB axiom ( op axiom )* )* RB )* RB -> ^( EXPR AGENT IF FACT THEN AXIOM axiom ) | ( LB AGENT )* RB ( LB IFF ( LB fact ( op fact )* )* RB THEN ( LB axiom ( op axiom )* )* RB )* RB -> ^( EXPR AGENT IFF FACT THEN AXIOM axiom ) | ( LB AGENT )* RB ( LB axiom ( op axiom )* )* RB -> ^( EXPR AGENT AXIOM axiom ) );
    def expr(self, ):

        retval = self.expr_return()
        retval.start = self.input.LT(1)

        root_0 = None

        LB16 = None
        AGENT17 = None
        RB18 = None
        LB19 = None
        IF20 = None
        LB21 = None
        RB25 = None
        THEN26 = None
        LB27 = None
        RB31 = None
        RB32 = None
        LB33 = None
        AGENT34 = None
        RB35 = None
        LB36 = None
        IFF37 = None
        LB38 = None
        RB42 = None
        THEN43 = None
        LB44 = None
        RB48 = None
        RB49 = None
        LB50 = None
        AGENT51 = None
        RB52 = None
        LB53 = None
        RB57 = None
        fact22 = None

        op23 = None

        fact24 = None

        axiom28 = None

        op29 = None

        axiom30 = None

        fact39 = None

        op40 = None

        fact41 = None

        axiom45 = None

        op46 = None

        axiom47 = None

        axiom54 = None

        op55 = None

        axiom56 = None


        LB16_tree = None
        AGENT17_tree = None
        RB18_tree = None
        LB19_tree = None
        IF20_tree = None
        LB21_tree = None
        RB25_tree = None
        THEN26_tree = None
        LB27_tree = None
        RB31_tree = None
        RB32_tree = None
        LB33_tree = None
        AGENT34_tree = None
        RB35_tree = None
        LB36_tree = None
        IFF37_tree = None
        LB38_tree = None
        RB42_tree = None
        THEN43_tree = None
        LB44_tree = None
        RB48_tree = None
        RB49_tree = None
        LB50_tree = None
        AGENT51_tree = None
        RB52_tree = None
        LB53_tree = None
        RB57_tree = None
        stream_IFF = RewriteRuleTokenStream(self._adaptor, "token IFF")
        stream_AGENT = RewriteRuleTokenStream(self._adaptor, "token AGENT")
        stream_LB = RewriteRuleTokenStream(self._adaptor, "token LB")
        stream_THEN = RewriteRuleTokenStream(self._adaptor, "token THEN")
        stream_RB = RewriteRuleTokenStream(self._adaptor, "token RB")
        stream_IF = RewriteRuleTokenStream(self._adaptor, "token IF")
        stream_fact = RewriteRuleSubtreeStream(self._adaptor, "rule fact")
        stream_op = RewriteRuleSubtreeStream(self._adaptor, "rule op")
        stream_axiom = RewriteRuleSubtreeStream(self._adaptor, "rule axiom")
        try:
            try:
                # Deo.g:61:2: ( ( LB AGENT )* RB ( LB IF ( LB fact ( op fact )* )* RB THEN ( LB axiom ( op axiom )* )* RB )* RB -> ^( EXPR AGENT IF FACT THEN AXIOM axiom ) | ( LB AGENT )* RB ( LB IFF ( LB fact ( op fact )* )* RB THEN ( LB axiom ( op axiom )* )* RB )* RB -> ^( EXPR AGENT IFF FACT THEN AXIOM axiom ) | ( LB AGENT )* RB ( LB axiom ( op axiom )* )* RB -> ^( EXPR AGENT AXIOM axiom ) )
                alt19 = 3
                alt19 = self.dfa19.predict(self.input)
                if alt19 == 1:
                    # Deo.g:61:4: ( LB AGENT )* RB ( LB IF ( LB fact ( op fact )* )* RB THEN ( LB axiom ( op axiom )* )* RB )* RB
                    pass 
                    # Deo.g:61:4: ( LB AGENT )*
                    while True: #loop4
                        alt4 = 2
                        LA4_0 = self.input.LA(1)

                        if (LA4_0 == LB) :
                            alt4 = 1


                        if alt4 == 1:
                            # Deo.g:61:5: LB AGENT
                            pass 
                            LB16=self.match(self.input, LB, self.FOLLOW_LB_in_expr407) 
                            stream_LB.add(LB16)
                            AGENT17=self.match(self.input, AGENT, self.FOLLOW_AGENT_in_expr409) 
                            stream_AGENT.add(AGENT17)


                        else:
                            break #loop4


                    RB18=self.match(self.input, RB, self.FOLLOW_RB_in_expr413) 
                    stream_RB.add(RB18)
                    # Deo.g:61:19: ( LB IF ( LB fact ( op fact )* )* RB THEN ( LB axiom ( op axiom )* )* RB )*
                    while True: #loop9
                        alt9 = 2
                        LA9_0 = self.input.LA(1)

                        if (LA9_0 == LB) :
                            alt9 = 1


                        if alt9 == 1:
                            # Deo.g:61:20: LB IF ( LB fact ( op fact )* )* RB THEN ( LB axiom ( op axiom )* )* RB
                            pass 
                            LB19=self.match(self.input, LB, self.FOLLOW_LB_in_expr416) 
                            stream_LB.add(LB19)
                            IF20=self.match(self.input, IF, self.FOLLOW_IF_in_expr421) 
                            stream_IF.add(IF20)
                            # Deo.g:62:6: ( LB fact ( op fact )* )*
                            while True: #loop6
                                alt6 = 2
                                LA6_0 = self.input.LA(1)

                                if (LA6_0 == LB) :
                                    alt6 = 1


                                if alt6 == 1:
                                    # Deo.g:62:7: LB fact ( op fact )*
                                    pass 
                                    LB21=self.match(self.input, LB, self.FOLLOW_LB_in_expr424) 
                                    stream_LB.add(LB21)
                                    self._state.following.append(self.FOLLOW_fact_in_expr426)
                                    fact22 = self.fact()

                                    self._state.following.pop()
                                    stream_fact.add(fact22.tree)
                                    # Deo.g:62:15: ( op fact )*
                                    while True: #loop5
                                        alt5 = 2
                                        LA5_0 = self.input.LA(1)

                                        if ((IF <= LA5_0 <= THEN) or (AND <= LA5_0 <= NOT)) :
                                            alt5 = 1


                                        if alt5 == 1:
                                            # Deo.g:62:16: op fact
                                            pass 
                                            self._state.following.append(self.FOLLOW_op_in_expr429)
                                            op23 = self.op()

                                            self._state.following.pop()
                                            stream_op.add(op23.tree)
                                            self._state.following.append(self.FOLLOW_fact_in_expr431)
                                            fact24 = self.fact()

                                            self._state.following.pop()
                                            stream_fact.add(fact24.tree)


                                        else:
                                            break #loop5




                                else:
                                    break #loop6


                            RB25=self.match(self.input, RB, self.FOLLOW_RB_in_expr437) 
                            stream_RB.add(RB25)
                            THEN26=self.match(self.input, THEN, self.FOLLOW_THEN_in_expr442) 
                            stream_THEN.add(THEN26)
                            # Deo.g:63:8: ( LB axiom ( op axiom )* )*
                            while True: #loop8
                                alt8 = 2
                                LA8_0 = self.input.LA(1)

                                if (LA8_0 == LB) :
                                    alt8 = 1


                                if alt8 == 1:
                                    # Deo.g:63:9: LB axiom ( op axiom )*
                                    pass 
                                    LB27=self.match(self.input, LB, self.FOLLOW_LB_in_expr445) 
                                    stream_LB.add(LB27)
                                    self._state.following.append(self.FOLLOW_axiom_in_expr447)
                                    axiom28 = self.axiom()

                                    self._state.following.pop()
                                    stream_axiom.add(axiom28.tree)
                                    # Deo.g:63:18: ( op axiom )*
                                    while True: #loop7
                                        alt7 = 2
                                        LA7_0 = self.input.LA(1)

                                        if ((IF <= LA7_0 <= THEN) or (AND <= LA7_0 <= NOT)) :
                                            alt7 = 1


                                        if alt7 == 1:
                                            # Deo.g:63:19: op axiom
                                            pass 
                                            self._state.following.append(self.FOLLOW_op_in_expr450)
                                            op29 = self.op()

                                            self._state.following.pop()
                                            stream_op.add(op29.tree)
                                            self._state.following.append(self.FOLLOW_axiom_in_expr452)
                                            axiom30 = self.axiom()

                                            self._state.following.pop()
                                            stream_axiom.add(axiom30.tree)


                                        else:
                                            break #loop7




                                else:
                                    break #loop8


                            RB31=self.match(self.input, RB, self.FOLLOW_RB_in_expr458) 
                            stream_RB.add(RB31)


                        else:
                            break #loop9


                    RB32=self.match(self.input, RB, self.FOLLOW_RB_in_expr462) 
                    stream_RB.add(RB32)

                    # AST Rewrite
                    # elements: THEN, AGENT, IF, axiom
                    # token labels: 
                    # rule labels: retval
                    # token list labels: 
                    # rule list labels: 
                    # wildcard labels: 

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 63:42: -> ^( EXPR AGENT IF FACT THEN AXIOM axiom )
                    # Deo.g:63:45: ^( EXPR AGENT IF FACT THEN AXIOM axiom )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(EXPR, "EXPR"), root_1)

                    self._adaptor.addChild(root_1, stream_AGENT.nextNode())
                    self._adaptor.addChild(root_1, stream_IF.nextNode())
                    self._adaptor.addChild(root_1, self._adaptor.createFromType(FACT, "FACT"))
                    self._adaptor.addChild(root_1, stream_THEN.nextNode())
                    self._adaptor.addChild(root_1, stream_axiom.nextTree())

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0


                elif alt19 == 2:
                    # Deo.g:64:4: ( LB AGENT )* RB ( LB IFF ( LB fact ( op fact )* )* RB THEN ( LB axiom ( op axiom )* )* RB )* RB
                    pass 
                    # Deo.g:64:4: ( LB AGENT )*
                    while True: #loop10
                        alt10 = 2
                        LA10_0 = self.input.LA(1)

                        if (LA10_0 == LB) :
                            alt10 = 1


                        if alt10 == 1:
                            # Deo.g:64:5: LB AGENT
                            pass 
                            LB33=self.match(self.input, LB, self.FOLLOW_LB_in_expr488) 
                            stream_LB.add(LB33)
                            AGENT34=self.match(self.input, AGENT, self.FOLLOW_AGENT_in_expr490) 
                            stream_AGENT.add(AGENT34)


                        else:
                            break #loop10


                    RB35=self.match(self.input, RB, self.FOLLOW_RB_in_expr494) 
                    stream_RB.add(RB35)
                    # Deo.g:64:19: ( LB IFF ( LB fact ( op fact )* )* RB THEN ( LB axiom ( op axiom )* )* RB )*
                    while True: #loop15
                        alt15 = 2
                        LA15_0 = self.input.LA(1)

                        if (LA15_0 == LB) :
                            alt15 = 1


                        if alt15 == 1:
                            # Deo.g:64:20: LB IFF ( LB fact ( op fact )* )* RB THEN ( LB axiom ( op axiom )* )* RB
                            pass 
                            LB36=self.match(self.input, LB, self.FOLLOW_LB_in_expr497) 
                            stream_LB.add(LB36)
                            IFF37=self.match(self.input, IFF, self.FOLLOW_IFF_in_expr502) 
                            stream_IFF.add(IFF37)
                            # Deo.g:65:7: ( LB fact ( op fact )* )*
                            while True: #loop12
                                alt12 = 2
                                LA12_0 = self.input.LA(1)

                                if (LA12_0 == LB) :
                                    alt12 = 1


                                if alt12 == 1:
                                    # Deo.g:65:8: LB fact ( op fact )*
                                    pass 
                                    LB38=self.match(self.input, LB, self.FOLLOW_LB_in_expr505) 
                                    stream_LB.add(LB38)
                                    self._state.following.append(self.FOLLOW_fact_in_expr507)
                                    fact39 = self.fact()

                                    self._state.following.pop()
                                    stream_fact.add(fact39.tree)
                                    # Deo.g:65:16: ( op fact )*
                                    while True: #loop11
                                        alt11 = 2
                                        LA11_0 = self.input.LA(1)

                                        if ((IF <= LA11_0 <= THEN) or (AND <= LA11_0 <= NOT)) :
                                            alt11 = 1


                                        if alt11 == 1:
                                            # Deo.g:65:17: op fact
                                            pass 
                                            self._state.following.append(self.FOLLOW_op_in_expr510)
                                            op40 = self.op()

                                            self._state.following.pop()
                                            stream_op.add(op40.tree)
                                            self._state.following.append(self.FOLLOW_fact_in_expr512)
                                            fact41 = self.fact()

                                            self._state.following.pop()
                                            stream_fact.add(fact41.tree)


                                        else:
                                            break #loop11




                                else:
                                    break #loop12


                            RB42=self.match(self.input, RB, self.FOLLOW_RB_in_expr518) 
                            stream_RB.add(RB42)
                            THEN43=self.match(self.input, THEN, self.FOLLOW_THEN_in_expr523) 
                            stream_THEN.add(THEN43)
                            # Deo.g:66:8: ( LB axiom ( op axiom )* )*
                            while True: #loop14
                                alt14 = 2
                                LA14_0 = self.input.LA(1)

                                if (LA14_0 == LB) :
                                    alt14 = 1


                                if alt14 == 1:
                                    # Deo.g:66:9: LB axiom ( op axiom )*
                                    pass 
                                    LB44=self.match(self.input, LB, self.FOLLOW_LB_in_expr526) 
                                    stream_LB.add(LB44)
                                    self._state.following.append(self.FOLLOW_axiom_in_expr528)
                                    axiom45 = self.axiom()

                                    self._state.following.pop()
                                    stream_axiom.add(axiom45.tree)
                                    # Deo.g:66:18: ( op axiom )*
                                    while True: #loop13
                                        alt13 = 2
                                        LA13_0 = self.input.LA(1)

                                        if ((IF <= LA13_0 <= THEN) or (AND <= LA13_0 <= NOT)) :
                                            alt13 = 1


                                        if alt13 == 1:
                                            # Deo.g:66:19: op axiom
                                            pass 
                                            self._state.following.append(self.FOLLOW_op_in_expr531)
                                            op46 = self.op()

                                            self._state.following.pop()
                                            stream_op.add(op46.tree)
                                            self._state.following.append(self.FOLLOW_axiom_in_expr533)
                                            axiom47 = self.axiom()

                                            self._state.following.pop()
                                            stream_axiom.add(axiom47.tree)


                                        else:
                                            break #loop13




                                else:
                                    break #loop14


                            RB48=self.match(self.input, RB, self.FOLLOW_RB_in_expr539) 
                            stream_RB.add(RB48)


                        else:
                            break #loop15


                    RB49=self.match(self.input, RB, self.FOLLOW_RB_in_expr543) 
                    stream_RB.add(RB49)

                    # AST Rewrite
                    # elements: THEN, AGENT, IFF, axiom
                    # token labels: 
                    # rule labels: retval
                    # token list labels: 
                    # rule list labels: 
                    # wildcard labels: 

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 66:42: -> ^( EXPR AGENT IFF FACT THEN AXIOM axiom )
                    # Deo.g:66:45: ^( EXPR AGENT IFF FACT THEN AXIOM axiom )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(EXPR, "EXPR"), root_1)

                    self._adaptor.addChild(root_1, stream_AGENT.nextNode())
                    self._adaptor.addChild(root_1, stream_IFF.nextNode())
                    self._adaptor.addChild(root_1, self._adaptor.createFromType(FACT, "FACT"))
                    self._adaptor.addChild(root_1, stream_THEN.nextNode())
                    self._adaptor.addChild(root_1, stream_axiom.nextTree())

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0


                elif alt19 == 3:
                    # Deo.g:67:4: ( LB AGENT )* RB ( LB axiom ( op axiom )* )* RB
                    pass 
                    # Deo.g:67:4: ( LB AGENT )*
                    while True: #loop16
                        alt16 = 2
                        LA16_0 = self.input.LA(1)

                        if (LA16_0 == LB) :
                            alt16 = 1


                        if alt16 == 1:
                            # Deo.g:67:5: LB AGENT
                            pass 
                            LB50=self.match(self.input, LB, self.FOLLOW_LB_in_expr570) 
                            stream_LB.add(LB50)
                            AGENT51=self.match(self.input, AGENT, self.FOLLOW_AGENT_in_expr572) 
                            stream_AGENT.add(AGENT51)


                        else:
                            break #loop16


                    RB52=self.match(self.input, RB, self.FOLLOW_RB_in_expr576) 
                    stream_RB.add(RB52)
                    # Deo.g:67:19: ( LB axiom ( op axiom )* )*
                    while True: #loop18
                        alt18 = 2
                        LA18_0 = self.input.LA(1)

                        if (LA18_0 == LB) :
                            alt18 = 1


                        if alt18 == 1:
                            # Deo.g:67:20: LB axiom ( op axiom )*
                            pass 
                            LB53=self.match(self.input, LB, self.FOLLOW_LB_in_expr579) 
                            stream_LB.add(LB53)
                            self._state.following.append(self.FOLLOW_axiom_in_expr584)
                            axiom54 = self.axiom()

                            self._state.following.pop()
                            stream_axiom.add(axiom54.tree)
                            # Deo.g:68:9: ( op axiom )*
                            while True: #loop17
                                alt17 = 2
                                LA17_0 = self.input.LA(1)

                                if ((IF <= LA17_0 <= THEN) or (AND <= LA17_0 <= NOT)) :
                                    alt17 = 1


                                if alt17 == 1:
                                    # Deo.g:68:10: op axiom
                                    pass 
                                    self._state.following.append(self.FOLLOW_op_in_expr587)
                                    op55 = self.op()

                                    self._state.following.pop()
                                    stream_op.add(op55.tree)
                                    self._state.following.append(self.FOLLOW_axiom_in_expr589)
                                    axiom56 = self.axiom()

                                    self._state.following.pop()
                                    stream_axiom.add(axiom56.tree)


                                else:
                                    break #loop17




                        else:
                            break #loop18


                    RB57=self.match(self.input, RB, self.FOLLOW_RB_in_expr595) 
                    stream_RB.add(RB57)

                    # AST Rewrite
                    # elements: axiom, AGENT
                    # token labels: 
                    # rule labels: retval
                    # token list labels: 
                    # rule list labels: 
                    # wildcard labels: 

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 68:30: -> ^( EXPR AGENT AXIOM axiom )
                    # Deo.g:68:33: ^( EXPR AGENT AXIOM axiom )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(EXPR, "EXPR"), root_1)

                    self._adaptor.addChild(root_1, stream_AGENT.nextNode())
                    self._adaptor.addChild(root_1, stream_axiom.nextTree())

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0


                retval.stop = self.input.LT(-1)


                retval.tree = self._adaptor.rulePostProcessing(root_0)
                self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:

            pass

        return retval

    # $ANTLR end "expr"


    # Delegated rules


    # lookup tables for DFA #19

    DFA19_eot = DFA.unpack(
        u"\10\uffff"
        )

    DFA19_eof = DFA.unpack(
        u"\10\uffff"
        )

    DFA19_min = DFA.unpack(
        u"\1\26\1\22\2\26\1\4\3\uffff"
        )

    DFA19_max = DFA.unpack(
        u"\1\27\1\22\2\27\1\17\3\uffff"
        )

    DFA19_accept = DFA.unpack(
        u"\5\uffff\1\1\1\2\1\3"
        )

    DFA19_special = DFA.unpack(
        u"\10\uffff"
        )

            
    DFA19_transition = [
        DFA.unpack(u"\1\1\1\2"),
        DFA.unpack(u"\1\3"),
        DFA.unpack(u"\1\4\1\5"),
        DFA.unpack(u"\1\1\1\2"),
        DFA.unpack(u"\1\5\1\6\7\uffff\3\7"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #19

    DFA19 = DFA
 

    FOLLOW_var_decl_in_prog82 = frozenset([11, 22, 23])
    FOLLOW_rule_decl_in_prog85 = frozenset([22, 23])
    FOLLOW_EOF_in_prog88 = frozenset([1])
    FOLLOW_expr_in_rule_decl117 = frozenset([1, 22, 23])
    FOLLOW_ID_in_var_decl144 = frozenset([12])
    FOLLOW_ASSN_in_var_decl146 = frozenset([16, 17, 18])
    FOLLOW_fact_in_var_decl148 = frozenset([1])
    FOLLOW_set_in_norm0 = frozenset([1])
    FOLLOW_set_in_fact0 = frozenset([1])
    FOLLOW_set_in_op0 = frozenset([1])
    FOLLOW_norm_in_axiom357 = frozenset([22])
    FOLLOW_LB_in_axiom359 = frozenset([16])
    FOLLOW_ACTION_in_axiom361 = frozenset([23])
    FOLLOW_RB_in_axiom363 = frozenset([1])
    FOLLOW_set_in_existent0 = frozenset([1])
    FOLLOW_LB_in_expr407 = frozenset([18])
    FOLLOW_AGENT_in_expr409 = frozenset([22, 23])
    FOLLOW_RB_in_expr413 = frozenset([22, 23])
    FOLLOW_LB_in_expr416 = frozenset([4])
    FOLLOW_IF_in_expr421 = frozenset([22, 23])
    FOLLOW_LB_in_expr424 = frozenset([16, 17, 18])
    FOLLOW_fact_in_expr426 = frozenset([4, 5, 6, 19, 20, 21, 22, 23])
    FOLLOW_op_in_expr429 = frozenset([16, 17, 18])
    FOLLOW_fact_in_expr431 = frozenset([4, 5, 6, 19, 20, 21, 22, 23])
    FOLLOW_RB_in_expr437 = frozenset([6])
    FOLLOW_THEN_in_expr442 = frozenset([22, 23])
    FOLLOW_LB_in_expr445 = frozenset([13, 14, 15])
    FOLLOW_axiom_in_expr447 = frozenset([4, 5, 6, 19, 20, 21, 22, 23])
    FOLLOW_op_in_expr450 = frozenset([13, 14, 15])
    FOLLOW_axiom_in_expr452 = frozenset([4, 5, 6, 19, 20, 21, 22, 23])
    FOLLOW_RB_in_expr458 = frozenset([22, 23])
    FOLLOW_RB_in_expr462 = frozenset([1])
    FOLLOW_LB_in_expr488 = frozenset([18])
    FOLLOW_AGENT_in_expr490 = frozenset([22, 23])
    FOLLOW_RB_in_expr494 = frozenset([22, 23])
    FOLLOW_LB_in_expr497 = frozenset([5])
    FOLLOW_IFF_in_expr502 = frozenset([22, 23])
    FOLLOW_LB_in_expr505 = frozenset([16, 17, 18])
    FOLLOW_fact_in_expr507 = frozenset([4, 5, 6, 19, 20, 21, 22, 23])
    FOLLOW_op_in_expr510 = frozenset([16, 17, 18])
    FOLLOW_fact_in_expr512 = frozenset([4, 5, 6, 19, 20, 21, 22, 23])
    FOLLOW_RB_in_expr518 = frozenset([6])
    FOLLOW_THEN_in_expr523 = frozenset([22, 23])
    FOLLOW_LB_in_expr526 = frozenset([13, 14, 15])
    FOLLOW_axiom_in_expr528 = frozenset([4, 5, 6, 19, 20, 21, 22, 23])
    FOLLOW_op_in_expr531 = frozenset([13, 14, 15])
    FOLLOW_axiom_in_expr533 = frozenset([4, 5, 6, 19, 20, 21, 22, 23])
    FOLLOW_RB_in_expr539 = frozenset([22, 23])
    FOLLOW_RB_in_expr543 = frozenset([1])
    FOLLOW_LB_in_expr570 = frozenset([18])
    FOLLOW_AGENT_in_expr572 = frozenset([22, 23])
    FOLLOW_RB_in_expr576 = frozenset([22, 23])
    FOLLOW_LB_in_expr579 = frozenset([13, 14, 15])
    FOLLOW_axiom_in_expr584 = frozenset([4, 5, 6, 19, 20, 21, 22, 23])
    FOLLOW_op_in_expr587 = frozenset([13, 14, 15])
    FOLLOW_axiom_in_expr589 = frozenset([4, 5, 6, 19, 20, 21, 22, 23])
    FOLLOW_RB_in_expr595 = frozenset([1])



def main(argv, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr):
    from antlr3.main import ParserMain
    main = ParserMain("DeoLexer", DeoParser)
    main.stdin = stdin
    main.stdout = stdout
    main.stderr = stderr
    main.execute(argv)


if __name__ == '__main__':
    main(sys.argv)
